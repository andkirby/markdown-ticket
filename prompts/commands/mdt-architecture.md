# MDT Architecture Design Workflow (v9)

Surface architectural decisions before implementation. Output is minimal but complete.

**Core Principle**: Capture decisions that matter. Skip ceremony that duplicates code.

## User Input

```text
$ARGUMENTS
```

## Session Context

Use `{TICKETS_PATH}` in all file path templates below (if it's not defined read ticketsPath key from .mdt-config.toml).

## Output Location

| Mode | Output | Criteria |
|------|--------|----------|
| **Prep** (`--prep` flag) | `{TICKETS_PATH}/{CR-KEY}/prep/architecture.md` | Preparatory refactoring design |
| **Simple** | `## Architecture Design` in CR | ≤60 lines output |
| **Complex** | `{TICKETS_PATH}/{CR-KEY}/architecture.md` | >60 lines output |

Don't pre-calculate complexity scores. Write the architecture, then decide where it goes based on actual size.

## What Good Architecture Output Looks Like

**Target**: 40-80 lines for most features. Max 150 lines for complex systems.

**Must have**:
- Overview (2-3 sentences)
- Pattern name + why
- Structure (file tree)
- Size limits per module
- Extension rule

**Include only if needed**:
- Build vs Use decisions (if evaluated)
- Component diagram (if >3 components with non-obvious relationships)
- Error philosophy (if non-trivial failure modes)

**Never include**:
- Requirement-to-component mapping tables (code is the mapping)
- Implementation code snippets (they drift from reality)
- Bug fix history (git tracks this)
- Exhaustive domain alignment tables (2-3 key concepts max)

## Execution Steps

### Step 0: Detect Mode

Check for `--prep` flag in `$ARGUMENTS`. If present, mode is `prep`.

### Step 1: Load Context

1. `mdt-all:get_cr` with `mode="full"` — abort if CR doesn't exist
2. Load optional context if exists:
   - `poc.md` — use validated decisions directly
   - `requirements.md` — understand scope (don't map exhaustively)
   - `domain.md` — respect aggregate boundaries
   - `domain-audit.md` — **PRIMARY for prep mode** (structural diagnosis)
3. Extract from CR: problem, affected files, new files, scope
4. Check project CLAUDE.md for conventions

### Step 2: Identify Decisions

**2.1 Check what's already decided in CR**

Read CR Section 2 (Decision) and Section 3 (Alternatives). Don't re-evaluate these.

**2.2 Build vs Use (for capabilities >50 lines)**

| Capability | Build | Use Existing | Decision |
|------------|-------|--------------|----------|
| {capability} | {effort} | {package + fit} | {Build/Use: why} |

Only evaluate capabilities that are:
- Common solved problems (CLI parsing, HTTP, validation, dates)
- Would be >50 lines custom

**2.3 Structural decisions**

Surface implicit choices:
- Single file vs multiple files?
- Where does logic live?
- How to extend later?

Present max 5 questions with recommendations.

### Step 3: Generate Architecture

Write the architecture. Keep it minimal.

---

## Output Template

```markdown
# Architecture: {CR-KEY}

**Source**: [{CR-KEY}](../{CR-KEY}.md)
**Generated**: {YYYY-MM-DD}

## Overview

{2-3 sentences: what this achieves, key constraint, design philosophy}

## Pattern

**{Pattern name}** — {why it fits}

## Key Dependencies

{Only if Build vs Use decisions were made}

| Capability | Decision | Rationale |
|------------|----------|-----------|
| {capability} | {package or "Build custom"} | {one line why} |

{Or omit section entirely if no significant decisions}

## Structure

```
{source_dir}/
  ├── {file tree, 5-15 lines}
```

## Size Guidance

| Module | Role | Limit | Hard Max |
|--------|------|-------|----------|
| `{path}` | {role} | {N} | {N×1.5} |

## Error Philosophy

{Only if non-trivial failure handling}

{1-3 sentences describing the error handling approach, not a table of every scenario}

Example: "Detection failures return undefined and never block summarization. All error paths are silent — the feature degrades gracefully."

## Extension Rule

To add {X}: {concrete steps with size limit}

---
*Generated by /mdt:architecture*
```

**That's it.** No component boundary tables, no requirement coverage matrices, no implementation notes with code blocks.

---

## Output Location Decision

After writing:
- **Prep mode**: Always save to `{TICKETS_PATH}/{CR-KEY}/prep/architecture.md`
- **≤60 lines**: Embed as `## Architecture Design` section in CR
- **>60 lines**: Save to `{TICKETS_PATH}/{CR-KEY}/architecture.md`, add summary link in CR

## CR Summary (when extracting)

```markdown
## Architecture Design

See [architecture.md](./{CR-KEY}/architecture.md)

- **Pattern**: {name}
- **Key constraint**: {most important limit}
- **Extension**: {one-liner}
```

## Save

**Prep mode**: Write to `{TICKETS_PATH}/{CR-KEY}/prep/architecture.md` (creates `prep/` directory)

**Embed**: `mdt-all:manage_cr_sections` to insert after Section 2

**Extract**: Write file, then add summary link to CR

## Size Guidance Reference

| Role | Limit | Hard Max |
|------|-------|----------|
| Orchestration | 100 | 150 |
| Feature module | 200 | 300 |
| Complex logic | 300 | 450 |
| Utility | 75 | 110 |

## Anti-Patterns

| Don't | Do |
|-------|-----|
| Requirement mapping tables | Let code be the mapping |
| Code snippets in architecture | Describe intent, not implementation |
| Every error scenario in a table | State the error philosophy in prose |
| Domain alignment for every concept | Mention 2-3 key aggregates if relevant |
| "Bug fixes" or "Refinements" sections | Architecture describes target state only |
| Component tables repeating the file tree | File tree with comments is enough |

## Quality Check

Before saving, verify:
- [ ] Overview is 2-3 sentences (not a paragraph)
- [ ] Structure shows concrete paths (not abstract names)
- [ ] Every module has a size limit
- [ ] Extension rule includes size constraint
- [ ] Total output is 40-150 lines (not 400+)

## Completion

**Prep mode**:
```markdown
## Prep Architecture Complete

**CR**: {CR-KEY}
**Output**: prep/architecture.md
**Size**: {N} lines

**Next**: `/mdt:tests {CR-KEY} --prep`
```

**Feature mode**:
```markdown
## Architecture Complete

**CR**: {CR-KEY}
**Output**: {CR section | architecture.md}
**Size**: {N} lines

**Pattern**: {name}
**Key constraint**: {most important}

**Next**: `/mdt:tasks {CR-KEY}`
```

Context: $ARGUMENTS
