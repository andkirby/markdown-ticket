# MDT Domain Lens (v1)

Surface strategic DDD constraints before architectural decisions. Output is intentionally minimal — principles only, not prescriptions.

**Core Principle**: Identify domain boundaries and invariants that should constrain structural decisions downstream.

## User Input

```text
$ARGUMENTS
```

## Output

Creates `docs/CRs/{CR-KEY}/domain.md` (~15-25 lines)

## When to Use

| CR Type | Use Domain Lens? |
|---------|------------------|
| New feature with business logic | ✅ Yes |
| Complex integration across modules | ✅ Yes |
| Domain model changes | ✅ Yes |
| Simple CRUD | ❌ Skip |
| Refactoring / Tech-debt | ❌ Skip |
| Infrastructure / Config | ❌ Skip |
| Bug fix | ❌ Skip |

## What This Is NOT

- ❌ Class/file structure recommendations (architecture's job)
- ❌ Verbose domain model documentation
- ❌ Pattern prescriptions ("use repository pattern")
- ❌ Implementation guidance

## Execution Steps

### Step 1: Load Context

1. `mdt-all:get_cr` with `mode="full"` — abort if CR doesn't exist
2. Load `docs/CRs/{CR-KEY}/requirements.md` if exists
3. Scan codebase for existing domain patterns:
   - Entity/model directories
   - Service layer organization
   - Event/message patterns
   - Existing aggregate boundaries

### Step 2: Identify Bounded Context(s)

**Question**: What business capability does this CR touch?

Look for:
- Distinct business vocabularies (same word, different meanings)
- Independent lifecycles (can this change without that?)
- Team/ownership boundaries
- Transaction boundaries

**Output format**:
```
Primary: {Context Name}
Touches: {Other Context 1}, {Other Context 2}
```

If CR stays within single context: `Primary: {Context Name}` only.

### Step 3: Identify Aggregate Boundaries

**Question**: What's the consistency boundary?

For each significant entity in CR scope:

| Concept | Role | Contains | Boundary |
|---------|------|----------|----------|
| `{Name}` | Root / Internal / Value | {children if root} | {what changes together} |

**Aggregate Root indicators**:
- Has global identity (ID referenced externally)
- Enforces invariants across children
- Transaction boundary
- Entry point for operations

**Internal Entity indicators**:
- Identity only meaningful within aggregate
- Cannot be modified without going through root
- Lifecycle tied to root

**Value Object indicators**:
- No identity, only attributes
- Immutable
- Interchangeable if attributes equal

### Step 4: Surface Invariants

**Question**: What business rules must ALWAYS be true?

| Invariant | Scope | Enforcement |
|-----------|-------|-------------|
| `{rule in plain English}` | `{Aggregate}` | In aggregate / At boundary / Via event |

**Enforcement guidance**:
- **In aggregate**: Rule involves only data within one aggregate
- **At boundary**: Rule checked on entry to bounded context
- **Via event**: Rule spans aggregates, enforce eventually

### Step 5: Note Language Alignment

**Question**: Does CR terminology match code terminology?

| CR/Requirements Term | Code Term | Action |
|---------------------|-----------|--------|
| `{term from CR}` | `{term in code}` | Align / Keep both / Clarify |

Only note mismatches that could cause confusion.

### Step 6: Flag Cross-Context Operations

**Question**: Does this CR require coordination across bounded contexts?

| Operation | From | To | Pattern |
|-----------|------|----|---------|
| `{what happens}` | `{Context A}` | `{Context B}` | Event / Service / Saga |

**Pattern guidance**:
- **Event**: Fire-and-forget, eventual consistency OK
- **Service**: Synchronous call needed, query or command
- **Saga**: Multi-step, compensating transactions needed

### Step 7: Generate Output

Create `docs/CRs/{CR-KEY}/domain.md`:

```markdown
# Domain Constraints: {CR-KEY}

**Context**: {Primary context} {→ touches: X, Y if applicable}

## Aggregates

| Concept | Role | Contains |
|---------|------|----------|
| `{Name}` | Root | {children} |
| `{Name}` | Internal | — |
| `{Name}` | Value | — |

## Invariants

| Rule | Scope | Enforce |
|------|-------|---------|
| {plain English rule} | `{Aggregate}` | {where} |

## Language

| CR Term | Code Term |
|---------|-----------|
| {term} | {term} |

{Only if mismatches exist, otherwise omit section}

## Cross-Context

| Operation | Contexts | Pattern |
|-----------|----------|---------|
| {operation} | A → B | {pattern} |

{Only if cross-context operations exist, otherwise omit section}

---
*Generated by /mdt:domain-lens — constraints for /mdt:architecture*
```

**Target size**: 15-25 lines. If output exceeds 30 lines, you're over-specifying.

### Step 8: Report Completion

```markdown
## Domain Analysis Complete

**CR**: {CR-KEY}
**Output**: `docs/CRs/{CR-KEY}/domain.md`

**Context**: {Primary} {→ touches if any}
**Aggregates**: {count}
**Invariants**: {count}
**Cross-Context Operations**: {count or "None"}

### Key Constraints for Architecture
{1-3 bullet points summarizing what architecture should respect}

### Next Steps
- Review domain constraints
- Run `/mdt:architecture {CR-KEY}` — will consume domain.md
```

---

## Examples

### Example 1: Order Management Feature

```markdown
# Domain Constraints: MDT-042

**Context**: Order Management → touches: Inventory, Payment

## Aggregates

| Concept | Role | Contains |
|---------|------|----------|
| `Order` | Root | LineItems, ShippingAddress |
| `LineItem` | Internal | — |
| `Product` | Reference | — (owned by Catalog) |

## Invariants

| Rule | Scope | Enforce |
|------|-------|---------|
| Order total = Σ(line prices) | `Order` | In aggregate |
| Cannot add items to shipped order | `Order` | In aggregate |
| Inventory reserved on order create | Cross-context | Via event |

## Cross-Context

| Operation | Contexts | Pattern |
|-----------|----------|---------|
| Reserve inventory | Order → Inventory | Event |
| Process payment | Order → Payment | Service |

---
*Generated by /mdt:domain-lens*
```

### Example 2: Simple Feature (Minimal Output)

```markdown
# Domain Constraints: MDT-043

**Context**: User Profile

## Aggregates

| Concept | Role | Contains |
|---------|------|----------|
| `UserProfile` | Root | Preferences, NotificationSettings |

## Invariants

| Rule | Scope | Enforce |
|------|-------|---------|
| Email must be unique | `UserProfile` | At boundary |

---
*Generated by /mdt:domain-lens*
```

---

## Behavioral Rules

- **Minimal output** — 15-25 lines target, 30 max
- **Principles not prescriptions** — "Order is aggregate root" not "Create OrderRepository"
- **Skip empty sections** — no Language section if no mismatches
- **One context focus** — if CR spans many contexts, focus on primary
- **Existing patterns respected** — align with codebase conventions
- **No file paths** — that's architecture's job
- **No size limits** — that's architecture's job

## Anti-Patterns to Avoid

❌ **Verbose domain model**: Pages of entity descriptions
✅ **Constraint summary**: Just boundaries and rules

❌ **Pattern prescription**: "Use Repository pattern for Order"
✅ **Boundary identification**: "Order is aggregate root"

❌ **Implementation leakage**: "OrderService should call InventoryClient"
✅ **Coordination flag**: "Order → Inventory needs event pattern"

❌ **Class diagrams**: Full UML with all attributes
✅ **Role table**: Entity | Root/Internal/Value | Contains

❌ **Always generate**: Every CR gets domain.md
✅ **Skip when irrelevant**: Refactoring, tech-debt, simple CRUD

## Quality Checklist

Before completing, verify:
- [ ] Output ≤ 30 lines
- [ ] No file paths or structure recommendations
- [ ] No pattern prescriptions
- [ ] Aggregates have clear Root/Internal/Value roles
- [ ] Invariants are business rules, not technical constraints
- [ ] Cross-context operations flagged with coordination pattern
- [ ] Empty sections omitted

## Integration

**Before**: CR exists, optionally requirements.md exists
**After**: `/mdt:architecture` consumes domain.md as constraints

Context: $ARGUMENTS
