# ADR Template for MCP mdt-all (v3 - Artifact Specification)

Guide for AI agents creating architectural decision records (ADRs) using MCP mdt-all ticket system.

**Core Principle**: Specify concrete artifacts (files, components, endpoints, methods), not behavioral descriptions. Every technical statement must reference what exists, not what it does.

## Critical Rules

1. **NO YAML frontmatter** - Auto-generated by MCP
2. **NO prose paragraphs** - Use bullets, tables, or lists only
3. **NO behavioral descriptions** - Say "Component Y" not "Component that does Y"
4. **NO placeholders** - Replace ALL with concrete details
5. **NO fabricated metrics** - Only if: (a) baseline exists, (b) verifiable, (c) explicitly required
6. **NO unmeasurable claims** - No adoption rates, productivity, satisfaction, time estimates
7. **NO generic adjectives** - No "user-friendly", "robust", "scalable" without specifics
8. **NO implementation code** - No code snippets, API signatures, config files in sections 1-6
9. **ARTIFACT REFERENCES REQUIRED** - Every technical point must name a file/component/endpoint
10. **Tables for comparisons** - Use tables for alternatives and specifications
11. **Keep concise** - Target 150-300 lines
12. **Proper headers** - Use `##` for main sections, `###` for subsections, NO bold text as headers

## Formatting Rules (CRITICAL)

- **Main sections**: `## 1. Description`, `## 2. Decision`, etc. (Use exact section names)
- **Subsections**: `### Problem`, `### Affected Artifacts`, etc.
- **NO bold text as section headers** - NEVER use `**Header**` as a section header
- **ALWAYS use markdown headers**: `###` for subsections, `####` for deeper subsections
- **Lists stay as lists** - Do NOT wrap bullet lists in code blocks
- **Code blocks ONLY in Section 7** (Deployment) for actual deployment commands
- **One H1 only** - The document title at the top, nothing else
- **NO duplicate headers** - Each section header must be unique, never repeat `## 1. Description` twice

## MCP Tool Usage

```json
{
  "project": "PROJECT_CODE",
  "type": "Architecture|Feature Enhancement|Bug Fix|Documentation",
  "data": {
    "title": "CR title",
    "phaseEpic": "Optional phase/epic",
    "assignee": "Optional team/person",
    "content": "Full markdown (no YAML)"
  }
}
```

---

## Document Structure

## 1. Description

### Problem
Write 2-3 bullets describing specific technical issues:
- Specific technical issue with artifact reference
- Missing capability with artifact reference
- Architectural gap with artifact reference

### Affected Artifacts
List files, components, and endpoints affected:
- `path/to/file.ts` (specific concern)
- `Component/ModuleName` (specific concern)
- `/api/endpoint` (specific concern)

### Scope
Clearly define boundaries:
- **Changes**: What will be modified/created
- **Unchanged**: What stays the same

## 2. Decision

### Chosen Approach
One sentence describing the decision.

### Rationale
Write 3-5 bullets with specific, measurable reasons:
- Technical reason (specific, measurable)
- Technical reason (specific, measurable)
- Trade-off accepted (specific)

## 3. Alternatives Considered

Use table format only:

| Approach | Key Difference | Why Rejected |
|----------|---------------|--------------|
| **Chosen Approach** | One-line description | **ACCEPTED** - Reason for choosing |
| Option A | One-line description | Specific reason |
| Option B | One-line description | Specific reason |

**IMPORTANT**: Mark the chosen approach with **ACCEPTED** in the "Why Rejected" column

## 4. Artifact Specifications

### New Artifacts

| Artifact | Type | Purpose |
|----------|------|---------|
| `src/components/X.tsx` | Component | Feature X UI |
| `/api/new-endpoint` | Endpoint | Data access |
| `services/Y.ts` | Service | Business logic |

### Modified Artifacts

| Artifact | Change Type | Modification |
|----------|-------------|--------------|
| `path/to/file.ts` | Method added | `methodName()` |
| `Component` | Prop changed | Added `propName` |

### Integration Points

| From | To | Interface |
|------|----|-----------| 
| Component X | Service Y | Method Z |
| API endpoint | Database | Query type |

### Key Patterns
List patterns as bullets:
- Pattern name: Where applied (artifact reference)
- Pattern name: Where applied (artifact reference)

## 5. Acceptance Criteria

### Functional
Write artifact-specific, testable criteria as checkboxes (NOT in code blocks):
- [ ] File X exports method Y
- [ ] Component Z renders when condition A
- [ ] Endpoint /api/path returns status 200 for input B

### Non-Functional
Write measurable criteria as checkboxes (NOT in code blocks):
- [ ] Test coverage > X% (current: Y%)
- [ ] Operation completes in < Nms (current: Mms)
- [ ] Error type E thrown when condition F

### Testing
Write specific test cases as bullets (NOT in code blocks):
- Unit: Test file X, function Y, input Z → output W
- Integration: Component A + Service B → State C
- Manual: Action sequence → verify result

## 6. Verification

### By CR Type
Choose the appropriate verification approach:
- **Bug Fix**: Issue X no longer occurs in test case Y
- **Feature**: Artifact X exists and test Y passes
- **Refactoring**: Tests pass, metric M improved (before: A, after: B)
- **Performance**: Operation X < target (baseline: Y, target: Z)
- **Documentation**: Files [list] contain sections [list]

### Metrics
ONLY include metrics if ALL three conditions met:
1. Baseline measurement exists
2. Can be verified through testing/measurement
3. CR explicitly targets this metric

If no metrics applicable, list verifiable artifacts that exist after implementation.

## 7. Deployment

### Simple Changes
Use bullets:
- Deployment method
- Configuration changes required

### Complex Changes
Use table format:

| Phase | Artifacts Deployed | Rollback |
|-------|-------------------|----------|
| 1 | File A, B | Revert commits X, Y |
| 2 | File C, D | Disable feature flag |

Code blocks ARE allowed in this section for deployment commands:
```bash
npm run deploy
kubectl apply -f config.yaml
```

---

## Quality Checklist

Before submitting, verify:
- [ ] Every technical statement references a concrete artifact (file/component/endpoint/method)
- [ ] NO paragraphs describing "what it does" - only specifications of what exists
- [ ] Problem section references specific artifacts that have the problem
- [ ] Alternatives table shows concrete differences, not philosophy
- [ ] Section 4 uses tables for specifications
- [ ] Acceptance criteria reference specific artifacts and tests
- [ ] Verification is measurable or references concrete artifacts
- [ ] NO generic adjectives without supporting specifics
- [ ] Section headers use `##` and `###`, NOT bold text
- [ ] Lists are NOT wrapped in code blocks (except Section 7 deployment commands)
- [ ] Only ONE H1 (`#`) header - the document title
- [ ] All metrics have baselines OR section describes artifacts only

---

This ensures artifact-focused, properly formatted specification documents.