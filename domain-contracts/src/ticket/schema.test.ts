/**
 * Tests for: MDT-101 - Ticket/CR Schema
 * Purpose: Behavioral preservation - lock current Ticket interface shape
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 *
 * These tests document the CURRENT behavior from shared/models/Ticket.ts
 * that MUST be preserved when migrating to Zod schemas.
 */

import { z } from 'zod';
import { TicketSchema } from './schema';

// Import current implementation to document behavior
import {
  Ticket,
  TicketData,
  TicketUpdateAttrs,
  TicketFilters,
  normalizeTicket,
  arrayToString,
  TICKET_UPDATE_ALLOWED_ATTRS
} from '../../../shared/models/Ticket';

describe('Ticket Schema - Behavioral Preservation', () => {
  // Lock the current Ticket interface shape from shared/models/Ticket.ts
  const minimalValidTicket: Ticket = {
    code: 'MDT-001',
    title: 'Test Ticket',
    status: 'Proposed',
    type: 'Feature Enhancement',
    priority: 'Medium',
    dateCreated: new Date('2024-01-01'),
    lastModified: new Date('2024-01-01'),
    content: '# Test Content\n\n## Description\n\nTest description',
    filePath: '/path/to/ticket.md',
    relatedTickets: [],
    dependsOn: [],
    blocks: []
  };

  describe('Ticket Interface Shape', () => {
    it('has all required fields with correct types', () => {
      // Core required fields
      expect(typeof minimalValidTicket.code === 'string').toBe(true);
      expect(typeof minimalValidTicket.title === 'string').toBe(true);
      expect(typeof minimalValidTicket.status === 'string').toBe(true);
      expect(typeof minimalValidTicket.type === 'string').toBe(true);
      expect(typeof minimalValidTicket.priority === 'string').toBe(true);
      expect(typeof minimalValidTicket.content === 'string').toBe(true);
      expect(typeof minimalValidTicket.filePath === 'string').toBe(true);

      // Date fields
      expect(minimalValidTicket.dateCreated).toBeInstanceOf(Date);
      expect(minimalValidTicket.lastModified).toBeInstanceOf(Date);

      // Array fields (always present, even if empty)
      expect(Array.isArray(minimalValidTicket.relatedTickets)).toBe(true);
      expect(Array.isArray(minimalValidTicket.dependsOn)).toBe(true);
      expect(Array.isArray(minimalValidTicket.blocks)).toBe(true);
    });

    it('accepts optional fields', () => {
      const ticketWithOptionals: Ticket = {
        ...minimalValidTicket,
        phaseEpic: 'Phase 1',
        assignee: 'user@example.com',
        implementationDate: new Date('2024-01-03'),
        implementationNotes: 'Implementation notes',
      };

      expect(ticketWithOptionals.phaseEpic).toBe('Phase 1');
      expect(ticketWithOptionals.assignee).toBe('user@example.com');
      expect(ticketWithOptionals.implementationDate).toBeInstanceOf(Date);
      expect(ticketWithOptionals.implementationNotes).toBe('Implementation notes');
    });
  });

  describe('TicketData Interface', () => {
    it('defines required fields for ticket creation', () => {
      const ticketData: TicketData = {
        title: 'New Ticket',
        type: 'Feature Enhancement',
      };

      expect(typeof ticketData.title === 'string').toBe(true);
      expect(typeof ticketData.type === 'string').toBe(true);
    });

    it('defines optional fields with appropriate types', () => {
      const ticketData: TicketData = {
        title: 'New Ticket',
        type: 'Feature Enhancement',
        priority: 'High',
        phaseEpic: 'Phase 1',
        impactAreas: ['UI', 'API'],
        relatedTickets: 'MDT-001, MDT-002',
        dependsOn: 'MDT-000',
        blocks: 'MDT-003',
        assignee: 'user@example.com',
        content: '# Test Content',
      };

      expect(ticketData.priority).toBe('High');
      expect(ticketData.phaseEpic).toBe('Phase 1');
      expect(Array.isArray(ticketData.impactAreas)).toBe(true);
      expect(ticketData.relatedTickets).toBe('MDT-001, MDT-002');
      expect(ticketData.dependsOn).toBe('MDT-000');
      expect(ticketData.blocks).toBe('MDT-003');
      expect(ticketData.assignee).toBe('user@example.com');
      expect(ticketData.content).toBe('# Test Content');
    });
  });

  describe('TicketUpdateAttrs Interface', () => {
    it('excludes title and content fields (immutable)', () => {
      // This should be a compile-time error if title is included
      const updateAttrs: TicketUpdateAttrs = {
        priority: 'High',
        phaseEpic: 'Phase 1',
        relatedTickets: 'MDT-002',
        dependsOn: 'MDT-001',
        blocks: 'MDT-003',
        assignee: 'user@example.com',
        implementationDate: new Date('2024-01-01'),
        implementationNotes: 'Notes',
      };

      // Verify the fields are present
      expect(updateAttrs.priority).toBe('High');
      expect(updateAttrs.phaseEpic).toBe('Phase 1');

      // Verify restricted fields are not part of the interface
      type RestrictedFields = 'title' | 'content' | 'code' | 'type' | 'status';
      // @ts-expect-error - These fields should not be allowed
      const hasTitle: RestrictedFields = updateAttrs.title;
      // @ts-expect-error - These fields should not be allowed
      const hasContent: RestrictedFields = updateAttrs.content;
    });
  });

  describe('TICKET_UPDATE_ALLOWED_ATTRS Constant', () => {
    it('contains exactly the allowed update attributes', () => {
      const expectedAttrs = [
        'priority',
        'phaseEpic',
        'relatedTickets',
        'dependsOn',
        'blocks',
        'assignee',
        'implementationDate',
        'implementationNotes'
      ];

      expectedAttrs.forEach(attr => {
        expect(TICKET_UPDATE_ALLOWED_ATTRS.has(attr as keyof TicketUpdateAttrs)).toBe(true);
      });

      // Verify the Set size matches expected count
      expect(TICKET_UPDATE_ALLOWED_ATTRS.size).toBe(expectedAttrs.length);

      // Verify restricted fields are NOT in the set
      const restrictedFields = ['code', 'title', 'type', 'status', 'content', 'dateCreated', 'lastModified'];
      restrictedFields.forEach(field => {
        expect(TICKET_UPDATE_ALLOWED_ATTRS.has(field as keyof TicketUpdateAttrs)).toBe(false);
      });
    });
  });

  describe('TicketFilters Interface', () => {
    it('supports single string filters', () => {
      const filters: TicketFilters = {
        status: 'In Progress',
        type: 'Bug Fix',
        priority: 'High',
      };

      expect(filters.status).toBe('In Progress');
      expect(filters.type).toBe('Bug Fix');
      expect(filters.priority).toBe('High');
    });

    it('supports array filters', () => {
      const filters: TicketFilters = {
        status: ['In Progress', 'Approved'],
        type: ['Bug Fix', 'Feature Enhancement'],
        priority: ['High', 'Critical'],
      };

      expect(Array.isArray(filters.status)).toBe(true);
      expect(Array.isArray(filters.type)).toBe(true);
      expect(Array.isArray(filters.priority)).toBe(true);
    });

    it('supports date range filters', () => {
      const filters: TicketFilters = {
        dateRange: {
          start: new Date('2024-01-01'),
          end: new Date('2024-12-31'),
        },
      };

      expect(filters.dateRange?.start).toBeInstanceOf(Date);
      expect(filters.dateRange?.end).toBeInstanceOf(Date);
    });
  });

  describe('normalizeTicket() Function Behavior', () => {
    it('maps key field to code', () => {
      const rawTicket = { key: 'MDT-001', title: 'Test' };
      const normalized = normalizeTicket(rawTicket);
      expect(normalized.code).toBe('MDT-001');
    });

    it('maps path field to filePath', () => {
      const rawTicket = { code: 'MDT-001', path: '/old/path.md' };
      const normalized = normalizeTicket(rawTicket);
      expect(normalized.filePath).toBe('/old/path.md');
    });

    it('provides default values for missing fields', () => {
      const rawTicket = {};
      const normalized = normalizeTicket(rawTicket);

      expect(normalized.code).toBe('');
      expect(normalized.title).toBe('');
      expect(normalized.status).toBe('Proposed');
      expect(normalized.type).toBe('Feature Enhancement');
      expect(normalized.priority).toBe('Medium');
      expect(normalized.content).toBe('');
      expect(normalized.filePath).toBe('');
      expect(normalized.phaseEpic).toBe('');
      expect(normalized.assignee).toBe('');
      expect(normalized.implementationNotes).toBe('');
    });

    it('handles Date objects correctly', () => {
      const now = new Date();
      const rawTicket = {
        code: 'MDT-001',
        dateCreated: now,
        lastModified: now,
        implementationDate: now,
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.dateCreated).toBe(now);
      expect(normalized.lastModified).toBe(now);
      expect(normalized.implementationDate).toBe(now);
    });

    it('parses ISO date strings to Date objects', () => {
      const rawTicket = {
        code: 'MDT-001',
        dateCreated: '2024-01-01T00:00:00Z',
        lastModified: '2024-01-02T00:00:00Z',
        implementationDate: '2024-01-03T00:00:00Z',
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.dateCreated).toBeInstanceOf(Date);
      expect(normalized.lastModified).toBeInstanceOf(Date);
      expect(normalized.implementationDate).toBeInstanceOf(Date);

      expect(normalized.dateCreated?.toISOString()).toBe('2024-01-01T00:00:00.000Z');
      expect(normalized.lastModified?.toISOString()).toBe('2024-01-02T00:00:00.000Z');
      expect(normalized.implementationDate?.toISOString()).toBe('2024-01-03T00:00:00.000Z');
    });

    it('returns null for invalid dates', () => {
      const rawTicket = {
        code: 'MDT-001',
        dateCreated: 'invalid-date',
        lastModified: '',
        implementationDate: null,
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.dateCreated).toBeNull();
      expect(normalized.lastModified).toBeNull();
      expect(normalized.implementationDate).toBeNull();
    });

    it('normalizes array fields from actual arrays', () => {
      const rawTicket = {
        code: 'MDT-001',
        relatedTickets: ['MDT-002', 'MDT-003'],
        dependsOn: ['MDT-001'],
        blocks: ['MDT-004', 'MDT-005'],
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.relatedTickets).toEqual(['MDT-002', 'MDT-003']);
      expect(normalized.dependsOn).toEqual(['MDT-001']);
      expect(normalized.blocks).toEqual(['MDT-004', 'MDT-005']);
    });

    it('normalizes array fields from comma-separated strings', () => {
      const rawTicket = {
        code: 'MDT-001',
        relatedTickets: 'MDT-002, MDT-003',
        dependsOn: 'MDT-001',
        blocks: 'MDT-004, MDT-005',
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.relatedTickets).toEqual(['MDT-002', 'MDT-003']);
      expect(normalized.dependsOn).toEqual(['MDT-001']);
      expect(normalized.blocks).toEqual(['MDT-004', 'MDT-005']);
    });

    it('filters out falsy values from arrays', () => {
      const rawTicket = {
        code: 'MDT-001',
        relatedTickets: ['MDT-002', '', 'MDT-003', null, undefined, false, 0],
        dependsOn: ['MDT-001', '', null],
        blocks: [],
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.relatedTickets).toEqual(['MDT-002', 'MDT-003']);
      expect(normalized.dependsOn).toEqual(['MDT-001']);
      expect(normalized.blocks).toEqual([]);
    });

    it('handles empty and whitespace-only strings in arrays', () => {
      const rawTicket = {
        code: 'MDT-001',
        relatedTickets: 'MDT-002,  , MDT-003,   , ',
        dependsOn: '',
        blocks: ' ',
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.relatedTickets).toEqual(['MDT-002', 'MDT-003']);
      expect(normalized.dependsOn).toEqual([]);
      expect(normalized.blocks).toEqual([]);
    });

    it('handles undefined arrays', () => {
      const rawTicket = {
        code: 'MDT-001',
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.relatedTickets).toEqual([]);
      expect(normalized.dependsOn).toEqual([]);
      expect(normalized.blocks).toEqual([]);
    });

    it('preserves all other fields as-is', () => {
      const rawTicket = {
        code: 'MDT-001',
        title: 'Test Title',
        status: 'In Progress',
        type: 'Bug Fix',
        priority: 'Critical',
        phaseEpic: 'Phase 2',
        assignee: 'developer@example.com',
        implementationNotes: 'Completed successfully',
        content: '# Content\n\nDetails here...',
        filePath: '/custom/path.md',
      };

      const normalized = normalizeTicket(rawTicket);
      expect(normalized.code).toBe('MDT-001');
      expect(normalized.title).toBe('Test Title');
      expect(normalized.status).toBe('In Progress');
      expect(normalized.type).toBe('Bug Fix');
      expect(normalized.priority).toBe('Critical');
      expect(normalized.phaseEpic).toBe('Phase 2');
      expect(normalized.assignee).toBe('developer@example.com');
      expect(normalized.implementationNotes).toBe('Completed successfully');
      expect(normalized.content).toBe('# Content\n\nDetails here...');
      expect(normalized.filePath).toBe('/custom/path.md');
    });
  });

  describe('arrayToString() Helper Function', () => {
    it('converts arrays to comma-separated strings', () => {
      const result = arrayToString(['MDT-001', 'MDT-002', 'MDT-003']);
      expect(result).toBe('MDT-001,MDT-002,MDT-003');
    });

    it('handles empty arrays', () => {
      const result = arrayToString([]);
      expect(result).toBe('');
    });

    it('handles null/undefined input', () => {
      const result1 = arrayToString(null as any);
      const result2 = arrayToString(undefined as any);
      expect(result1).toBe('');
      expect(result2).toBe('');
    });

    it('handles non-array input', () => {
      const result = arrayToString('not-an-array' as any);
      expect(result).toBe('');
    });
  });

  // Zod Schema Tests (will fail until schemas are implemented)
  describe('Zod Schema Implementation', () => {
    it('accepts valid ticket with all fields', () => {
      const result = TicketSchema.safeParse(minimalValidTicket);
      expect(result.success).toBe(true);
    });

    it('validates enum constraints for status', () => {
      const validStatuses = [
        'Proposed', 'Approved', 'In Progress', 'Implemented',
        'Rejected', 'On Hold', 'Superseded', 'Deprecated',
        'Duplicate', 'Partially Implemented'
      ];

      validStatuses.forEach(status => {
        const ticket = { ...minimalValidTicket, status };
        const result = TicketSchema.safeParse(ticket);
        expect(result.success).toBe(true);
      });
    });

    it('rejects invalid status values', () => {
      const invalidTicket = { ...minimalValidTicket, status: 'InvalidStatus' };
      const result = TicketSchema.safeParse(invalidTicket);
      expect(result.success).toBe(false);
    });

    it('validates enum constraints for type', () => {
      const validTypes = ['Architecture', 'Feature Enhancement', 'Bug Fix', 'Technical Debt', 'Documentation'];

      validTypes.forEach(type => {
        const ticket = { ...minimalValidTicket, type };
        const result = TicketSchema.safeParse(ticket);
        expect(result.success).toBe(true);
      });
    });

    it('validates enum constraints for priority', () => {
      const validPriorities = ['Low', 'Medium', 'High', 'Critical'];

      validPriorities.forEach(priority => {
        const ticket = { ...minimalValidTicket, priority };
        const result = TicketSchema.safeParse(ticket);
        expect(result.success).toBe(true);
      });
    });
  });
});