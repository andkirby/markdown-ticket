/**
 * Tests for: MDT-101 - Project Schema
 * Purpose: Behavioral preservation - lock current Project entity behavior from shared/models/Project.ts
 * Generated by: Claude TDD Orchestration
 * Status: RED (implementation pending - Zod schemas don't exist yet)
 *
 * These tests document the CURRENT behavior that must be preserved when migrating to Zod schemas.
 * All tests will fail until the Zod schemas are implemented to match this exact behavior.
 */

import {
  LocalProjectConfig,
  Project,
  ProjectConfig,
  getTicketsPath,
  isLegacyConfig,
  migrateLegacyConfig,
  validateProjectConfig
} from '../../../shared/models/Project';

describe('Project Entity - Behavioral Preservation Tests', () => {

  describe('LocalProjectConfig interface', () => {
    describe('shape validation', () => {
      it('accepts valid LocalProjectConfig with all required fields', () => {
        const validConfig: LocalProjectConfig = {
          project: {
            name: 'Test Project',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next',
            active: true,
            ticketsPath: 'docs/CRs'
          },
          document: {
            paths: ['docs'],
            excludeFolders: ['node_modules'],
            maxDepth: 5
          }
        };
        // This documents the expected shape - will fail until Zod schema exists
        expect(validConfig.project.name).toBe('Test Project');
        expect(validConfig.project.code).toBe('TEST');
        expect(validConfig.project.startNumber).toBe(1);
        expect(validConfig.project.active).toBe(true);
      });

      it('accepts LocalProjectConfig with minimal required fields', () => {
        const minimalConfig: LocalProjectConfig = {
          project: {
            name: 'Minimal Project',
            code: 'MIN',
            startNumber: 100,
            counterFile: '.counter',
            active: false
            // ticketsPath, path, description, repository, id are optional
          },
          document: {} // document fields are all optional
        };
        expect(minimalConfig.project.name).toBe('Minimal Project');
      });

      it('allows optional fields in project section', () => {
        const configWithOptions: LocalProjectConfig = {
          project: {
            id: 'local-id',
            name: 'Full Project',
            code: 'FULL',
            path: '/optional/path',
            startNumber: 1,
            counterFile: '.mdt-next',
            active: true,
            description: 'A complete project',
            repository: 'https://github.com/example/repo',
            ticketsPath: 'tickets'
          },
          document: {
            paths: ['src', 'docs'],
            excludeFolders: ['dist', 'node_modules'],
            maxDepth: 10
          }
        };
        expect(configWithOptions.project.id).toBe('local-id');
        expect(configWithOptions.project.description).toBe('A complete project');
        expect(configWithOptions.project.ticketsPath).toBe('tickets');
      });
    });
  });

  describe('Project interface', () => {
    describe('unified view combining global and local configs', () => {
      it('has required fields for unified Project model', () => {
        const project: Project = {
          id: 'unified-project-id',
          project: {
            name: 'Unified Project',
            path: '/absolute/project/path',
            configFile: '/absolute/project/path/.mdt-config.toml',
            active: true,
            description: 'Project description'
          },
          metadata: {
            dateRegistered: '2024-01-01T00:00:00Z',
            lastAccessed: '2024-01-01T00:00:00Z',
            version: '1.0.0'
          }
        };
        expect(project.id).toBe('unified-project-id');
        expect(project.project.name).toBe('Unified Project');
        expect(project.metadata.dateRegistered).toBe('2024-01-01T00:00:00Z');
      });

      it('includes optional strategy fields', () => {
        const projectWithStrategies: Project = {
          id: 'strategy-project',
          project: {
            name: 'Strategy Project',
            path: '/path',
            configFile: '/path/.mdt-config.toml',
            active: true,
            description: 'Shows strategy flags',
            code: 'STRAT',
            ticketsPath: 'docs/CRs'
          },
          metadata: {
            dateRegistered: '2024-01-01T00:00:00Z',
            lastAccessed: '2024-01-01T00:00:00Z',
            version: '1.0.0',
            globalOnly: true // Strategy 1: Global-Only Mode
          },
          autoDiscovered: true, // Strategy 3: Auto-Discovery Mode
          configPath: '/optional/config/path',
          registryFile: '/optional/registry/file'
        };
        expect(projectWithStrategies.metadata.globalOnly).toBe(true);
        expect(projectWithStrategies.autoDiscovered).toBe(true);
        expect(projectWithStrategies.configPath).toBe('/optional/config/path');
      });

      it('includes optional tickets and document sections', () => {
        const projectFull: Project = {
          id: 'full-project',
          project: {
            name: 'Full Project',
            path: '/path',
            configFile: '/path/.mdt-config.toml',
            active: true,
            description: 'Full project'
          },
          metadata: {
            dateRegistered: '2024-01-01T00:00:00Z',
            lastAccessed: '2024-01-01T00:00:00Z',
            version: '1.0.0'
          },
          tickets: {
            codePattern: '{code}-{number}'
          },
          document: {
            paths: ['docs', 'src'],
            excludeFolders: ['node_modules'],
            maxDepth: 3
          }
        };
        expect(projectFull.tickets?.codePattern).toBe('{code}-{number}');
        expect(projectFull.document?.paths).toEqual(['docs', 'src']);
      });
    });
  });

  describe('ProjectConfig legacy interface', () => {
    describe('backward compatibility shape', () => {
      it('matches LocalProjectConfig shape with optional active field', () => {
        // ProjectConfig is the same as LocalProjectConfig but with active being optional
        const legacyConfig: ProjectConfig = {
          project: {
            name: 'Legacy Project',
            code: 'LEG',
            startNumber: 1,
            counterFile: '.mdt-next',
            // active is optional in ProjectConfig
            ticketsPath: 'docs'
          },
          document: {
            paths: ['docs'],
            excludeFolders: ['node_modules']
          }
        };
        expect(legacyConfig.project.name).toBe('Legacy Project');
        expect(legacyConfig.project.active).toBeUndefined();
      });

      it('accepts active field when present', () => {
        const legacyWithActive: ProjectConfig = {
          project: {
            name: 'Legacy with Active',
            code: 'LWA',
            startNumber: 10,
            counterFile: '.counter',
            active: true,
            ticketsPath: 'crs'
          },
          document: {}
        };
        expect(legacyWithActive.project.active).toBe(true);
      });
    });
  });

  describe('getTicketsPath() function behavior', () => {
    describe('priority order: project.ticketsPath -> project.path -> defaultPath', () => {
      it('returns project.ticketsPath when present (highest priority)', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next',
            ticketsPath: 'custom/tickets',
            path: '/some/path' // Should be ignored
          },
          document: {}
        };
        expect(getTicketsPath(config)).toBe('custom/tickets');
      });

      it('falls back to project.path when ticketsPath not present', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: 'legacy/tickets/path' // This was used as tickets path in legacy format
          },
          document: {}
        };
        expect(getTicketsPath(config)).toBe('legacy/tickets/path');
      });

      it('returns default path when neither ticketsPath nor path present', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
            // No ticketsPath or path
          },
          document: {}
        };
        expect(getTicketsPath(config)).toBe('docs/CRs');
      });

      it('returns default path when config is null', () => {
        expect(getTicketsPath(null)).toBe('docs/CRs');
      });

      it('accepts custom default path parameter', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };
        expect(getTicketsPath(config, 'custom/default')).toBe('custom/default');
      });
    });
  });

  describe('isLegacyConfig() function behavior', () => {
    describe('legacy format detection', () => {
      it('returns true when project.path exists and ticketsPath does not', () => {
        const legacyConfig: ProjectConfig = {
          project: {
            name: 'Legacy',
            code: 'LEG',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: 'docs/tickets' // Legacy: path contains tickets path
          },
          document: {}
        };
        expect(isLegacyConfig(legacyConfig)).toBe(true);
      });

      it('returns false when both path and ticketsPath exist (new format)', () => {
        const newConfig: ProjectConfig = {
          project: {
            name: 'New',
            code: 'NEW',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: '/project/root', // New: path is project root
            ticketsPath: 'docs/tickets' // New: ticketsPath is explicit
          },
          document: {}
        };
        expect(isLegacyConfig(newConfig)).toBe(false);
      });

      it('returns false when only ticketsPath exists (new format)', () => {
        const newConfig2: ProjectConfig = {
          project: {
            name: 'New2',
            code: 'NEW2',
            startNumber: 1,
            counterFile: '.mdt-next',
            ticketsPath: 'tickets'
            // No path field
          },
          document: {}
        };
        expect(isLegacyConfig(newConfig2)).toBe(false);
      });

      it('returns false when neither path nor ticketsPath exist', () => {
        const configNoPaths: ProjectConfig = {
          project: {
            name: 'NoPaths',
            code: 'NOP',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };
        expect(isLegacyConfig(configNoPaths)).toBe(false);
      });

      it('returns false when config is null', () => {
        expect(isLegacyConfig(null)).toBe(false);
      });

      it('returns false when config.project is null/undefined', () => {
        expect(isLegacyConfig({} as any)).toBe(false);
        expect(isLegacyConfig({ project: null } as any)).toBe(false);
      });

      it('returns false when project.path is undefined', () => {
        const configNoPath: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: undefined
          },
          document: {}
        };
        expect(isLegacyConfig(configNoPath)).toBe(false);
      });
    });
  });

  describe('migrateLegacyConfig() function behavior', () => {
    describe('legacy to new format migration', () => {
      it('migrates legacy path to ticketsPath and sets path to "."', () => {
        const legacyConfig: ProjectConfig = {
          project: {
            name: 'Legacy',
            code: 'LEG',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: 'docs/CRs' // This was actually the tickets path
          },
          document: {}
        };

        const migrated = migrateLegacyConfig(legacyConfig);

        expect(migrated.project.path).toBe('.');
        expect(migrated.project.ticketsPath).toBe('docs/CRs');
        expect(migrated.project.name).toBe('Legacy'); // Other fields preserved
      });

      it('preserves all other fields during migration', () => {
        const legacyConfig: ProjectConfig = {
          project: {
            id: 'test-id',
            name: 'Legacy Project',
            code: 'LEG',
            startNumber: 42,
            counterFile: '.custom-counter',
            path: 'cr',
            description: 'A legacy project',
            repository: 'https://github.com/legacy/repo',
            active: false
          },
          document: {
            paths: ['docs'],
            excludeFolders: ['node_modules'],
            maxDepth: 5
          }
        };

        const migrated = migrateLegacyConfig(legacyConfig);

        expect(migrated.project.id).toBe('test-id');
        expect(migrated.project.name).toBe('Legacy Project');
        expect(migrated.project.code).toBe('LEG');
        expect(migrated.project.startNumber).toBe(42);
        expect(migrated.project.counterFile).toBe('.custom-counter');
        expect(migrated.project.path).toBe('.');
        expect(migrated.project.ticketsPath).toBe('cr');
        expect(migrated.project.description).toBe('A legacy project');
        expect(migrated.project.repository).toBe('https://github.com/legacy/repo');
        expect(migrated.project.active).toBe(false);
        expect(migrated.document?.paths).toEqual(['docs']);
        expect(migrated.document?.excludeFolders).toEqual(['node_modules']);
        expect(migrated.document?.maxDepth).toBe(5);
      });

      it('adds document section if missing in legacy config', () => {
        const legacyWithoutDoc: ProjectConfig = {
          project: {
            name: 'Legacy',
            code: 'LEG',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: 'tickets'
          }
          // No document section
        };

        const migrated = migrateLegacyConfig(legacyWithoutDoc);

        expect(migrated.document).toBeDefined();
        expect(migrated.document!.paths).toEqual([]);
        expect(migrated.document!.excludeFolders).toEqual([]);
      });

      it('handles legacy config with old document field names', () => {
        const legacyOldDoc: any = {
          project: {
            name: 'Legacy',
            code: 'LEG',
            startNumber: 1,
            counterFile: '.mdt-next',
            path: 'tickets'
          },
          document_paths: ['old/docs'], // Legacy field name
          exclude_folders: ['old/node_modules'] // Legacy field name
        };

        const migrated = migrateLegacyConfig(legacyOldDoc as ProjectConfig);

        expect(migrated.document?.paths).toEqual(['old/docs']);
        expect(migrated.document?.excludeFolders).toEqual(['old/node_modules']);
      });

      it('returns config unchanged if not legacy format', () => {
        const newConfig: ProjectConfig = {
          project: {
            name: 'New',
            code: 'NEW',
            startNumber: 1,
            counterFile: '.mdt-next',
            ticketsPath: 'docs/CRs'
            // No path field
          },
          document: {}
        };

        const migrated = migrateLegacyConfig(newConfig);

        expect(migrated).toBe(newConfig); // Should be the same object reference
      });
    });
  });

  describe('validateProjectConfig() function behavior', () => {
    describe('validation rules for all configuration formats', () => {
      it('returns true for valid ProjectConfig with all required fields', () => {
        const validConfig: ProjectConfig = {
          project: {
            name: 'Valid Project',
            code: 'VALID',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };
        expect(validateProjectConfig(validConfig)).toBe(true);
      });

      it('returns false when config is null or undefined', () => {
        expect(validateProjectConfig(null)).toBe(false);
        expect(validateProjectConfig(undefined)).toBe(false);
      });

      it('returns false when config.project is missing', () => {
        expect(validateProjectConfig({})).toBe(false);
        expect(validateProjectConfig({ document: {} })).toBe(false);
      });

      it('validates project.name is required and non-empty string', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };

        expect(validateProjectConfig(config)).toBe(true);

        // Empty name
        config.project.name = '';
        expect(validateProjectConfig(config)).toBe(false);

        // Whitespace only
        config.project.name = '   ';
        expect(validateProjectConfig(config)).toBe(false);

        // Non-string
        config.project.name = 123 as any;
        expect(validateProjectConfig(config)).toBe(false);
      });

      it('validates project.code is required and non-empty string', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };

        expect(validateProjectConfig(config)).toBe(true);

        // Empty code
        config.project.code = '';
        expect(validateProjectConfig(config)).toBe(false);

        // Whitespace only
        config.project.code = '   ';
        expect(validateProjectConfig(config)).toBe(false);

        // Non-string
        config.project.code = 123 as any;
        expect(validateProjectConfig(config)).toBe(false);
      });

      it('validates project.path is optional but valid if present', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };

        // Undefined path is valid
        expect(validateProjectConfig(config)).toBe(true);

        // Valid string path
        config.project.path = '/valid/path';
        expect(validateProjectConfig(config)).toBe(true);

        // Empty string path is invalid
        config.project.path = '';
        expect(validateProjectConfig(config)).toBe(false);

        // Whitespace only path is invalid
        config.project.path = '   ';
        expect(validateProjectConfig(config)).toBe(false);
      });

      it('validates project.startNumber with flexible types', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };

        // Number is valid
        expect(validateProjectConfig(config)).toBe(true);

        // String number is valid
        config.project.startNumber = '42' as any;
        expect(validateProjectConfig(config)).toBe(true);

        // Non-numeric string is invalid
        config.project.startNumber = 'not-a-number' as any;
        expect(validateProjectConfig(config)).toBe(false);

        // Undefined is valid (optional)
        config.project.startNumber = undefined;
        expect(validateProjectConfig(config)).toBe(true);
      });

      it('validates optional fields accept undefined when present', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next',
            counterFile: undefined,
            description: undefined,
            repository: undefined
          },
          document: {}
        };
        expect(validateProjectConfig(config)).toBe(true);
      });

      it('validates document.paths as optional string array', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };

        // Undefined paths is valid
        expect(validateProjectConfig(config)).toBe(true);

        // Valid string array
        config.document!.paths = ['docs', 'src'];
        expect(validateProjectConfig(config)).toBe(true);

        // Empty array is valid
        config.document!.paths = [];
        expect(validateProjectConfig(config)).toBe(true);

        // Array with non-strings is invalid
        config.document!.paths = ['docs', 123] as any;
        expect(validateProjectConfig(config)).toBe(false);

        // Non-array is invalid
        config.document!.paths = 'not-array' as any;
        expect(validateProjectConfig(config)).toBe(false);
      });

      it('validates document.excludeFolders as optional string array', () => {
        const config: ProjectConfig = {
          project: {
            name: 'Test',
            code: 'TEST',
            startNumber: 1,
            counterFile: '.mdt-next'
          },
          document: {}
        };

        // Valid string array
        config.document!.excludeFolders = ['node_modules', '.git'];
        expect(validateProjectConfig(config)).toBe(true);

        // Array with non-strings is invalid
        config.document!.excludeFolders = ['node_modules', 123] as any;
        expect(validateProjectConfig(config)).toBe(false);
      });
    });
  });
});