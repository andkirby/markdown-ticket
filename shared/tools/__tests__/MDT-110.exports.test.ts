/**
 * Tests for: MDT-110 - Conditional Exports Configuration
 * Phase: 3 - Update Package Exports
 * Requirements: P3-1
 * Generated by: /mdt:tests
 * Status: ðŸ”´ RED (implementation pending)
 *
 * These tests verify that package.json conditional exports correctly
 * route to browser or Node.js implementations.
 *
 * NOTE: Tests verify implementation file existence and interface compatibility.
 * Actual conditional export routing happens at build/runtime by bundler.
 */

// We'll verify package.json exports by reading the file directly in tests
import fs from 'node:fs'
import path from 'node:path'
import { ProjectValidator as BrowserValidator } from '../ProjectValidator'
import { ProjectValidator as NodeValidator } from '../ProjectValidator.node'

interface PackageJsonExports {
  [key: string]: unknown
}

interface PackageJsonShape {
  exports?: PackageJsonExports
}

describe('mDT-110: Conditional Exports Configuration', () => {
  // Helper to read package.json
  const getPackageJson = () => {
    const pkgPath = path.resolve(__dirname, '../../package.json')
    return JSON.parse(fs.readFileSync(pkgPath, 'utf-8'))
  }

  // P3-1: Verify package.json exports structure
  describe('package.json exports field', () => {
    let packageJson: PackageJsonShape

    beforeEach(() => {
      packageJson = getPackageJson()
    })

    it('should have exports field defined', () => {
      expect(packageJson).toHaveProperty('exports')
    })

    it('should export ProjectValidator with conditions', () => {
      const exports = packageJson.exports as Record<string, unknown>
      expect('./tools/ProjectValidator' in exports).toBe(true)
    })

    it('should have browser condition pointing to .js file', () => {
      const validatorExport = packageJson.exports!['./tools/ProjectValidator'] as Record<string, unknown>
      expect(validatorExport).toHaveProperty('browser')
      expect(validatorExport.browser).toBe('./dist/tools/ProjectValidator.js')
    })

    it('should have node condition pointing to .node.js file', () => {
      const validatorExport = packageJson.exports!['./tools/ProjectValidator'] as Record<string, unknown>
      expect(validatorExport).toHaveProperty('node')
      expect(validatorExport.node).toBe('./dist/tools/ProjectValidator.node.js')
    })

    it('should have default condition pointing to .node.js file', () => {
      const validatorExport = packageJson.exports!['./tools/ProjectValidator'] as Record<string, unknown>
      expect(validatorExport).toHaveProperty('default')
      expect(validatorExport.default).toBe('./dist/tools/ProjectValidator.node.js')
    })
  })

  // P3-1: Verify both implementations exist
  describe('implementation files existence', () => {
    it('should have browser-safe implementation at ProjectValidator.ts', () => {
      const sourcePath = path.resolve(__dirname, '../ProjectValidator.ts')
      expect(fs.existsSync(sourcePath)).toBe(true)
    })

    it('should have Node.js extension at ProjectValidator.node.ts', () => {
      const nodePath = path.resolve(__dirname, '../ProjectValidator.node.ts')
      expect(fs.existsSync(nodePath)).toBe(true)
    })
  })

  // P3-1: Interface compatibility
  describe('interface compatibility', () => {
    it('should export same interface from both implementations', () => {
      // Both should have static validation methods
      const staticMethods = [
        'validateName',
        'validateCode',
        'validatePath',
        'validateDescription',
        'validateRepository',
        'expandTildePath',
        'isValidUrl',
        'generateCodeFromName',
        'validateTicketsPath',
      ]

      staticMethods.forEach((method) => {
        expect(BrowserValidator).toHaveProperty(method)
        expect(NodeValidator).toHaveProperty(method)
        expect(typeof BrowserValidator[method]).toBe('function')
        expect(typeof NodeValidator[method]).toBe('function')
      })
    })
  })

  // P3-1: Import path unchanged
  describe('single import path compatibility', () => {
    it('should allow imports from @mdt/shared/tools/ProjectValidator', () => {
      // This test verifies the import path works
      // The actual routing happens at build/runtime based on environment
      expect(BrowserValidator).toBeDefined()
    })
  })
})
